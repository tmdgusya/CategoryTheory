# 타입과 함수
원본 사이트: [Types and Functions](https://bartoszmilewski.com/2014/11/24/types-and-functions/)

---

> 이 글은 프로그래머를 위한 카테고리 이론이라는 책의 일부입니다. 이전 글은 [합성의 정수, 카테고리](/contents/part1/category-the-essence-of-composition.md) 입니다. 목차는 [여기서](/README.md) 확인하실 수 있습니다.

타입과 함수의 카테고리는 프로그래밍에서 중요한 역할을 합니다. 오늘은 타입이 무엇이고 왜 알아야 하는지 알아보겠습니다.

## 타입은 어디에서 쓰이나요?

어떤 타입을 사용할 때 static과 dynamic 또는 strong과 weak 중 어떤 것이 더 나은지에 대한 논쟁을 들어보셨을 것입니다. 하지만 이렇게 논쟁만 하는 건 의미가 없습니다.

<p align="center">
	<img src="/img/img_part1-2_1.jpg" width="258" />
</p>

아무렇게나 작성한 코드에 머신 러닝을 적용한다면 실행은 되는 코드가 될 것입니다. 하지만 우리의 고급 언어들에겐 문법과 타입의 오류를 찾아주는 컴파일러가 있으니 머신 러닝으로 생성한 코드도 실행되지 않을 것입니다. 이러한 타입 확인 과정은 터무니없는 프로그램이 생성되지 않도록 막아주는 방어막 역할을 합니다. 타입 불일치가 발견되는 시점은 동적 타입 언어의 경우엔 런타임이고 정적 타입 언어는 컴파일 시간이지만 타입 불일치가 발견된다는 사실은 같습니다. 올바르지 않은 프로그램에겐 실행할 기회조차 주어지면 안되기 때문입니다.

당연히 우리는 올바르지 않은 프로그램보단 올바른 프로그램을 만들어야 할 것입니다.

원숭이로 하는 실험 중엔 사고 실험이라는 실험이 있는데, 원숭이들에게 키보드를 주고 아무 키나 누르게 해서 결국에는 셰익스피어의 작품과 동일한 결과를 만드는 것을 목적으로 하는 실험입니다. 이 실험의 경우엔 맞춤법 검사기를 추가한다면 실패할 경우의 수를 엄청나게 줄일 것이고 그 검사기에 로미오가 사람이라는 것을 정의한다면 그를 나뭇잎 취급하진 않을 것입니다.

## 결합성에 대한 타입들

카테고리 이론은 합성 화살표에 대한 내용입니다. 하지만 아무 화살표 둘이 합성할 순 없습니다. 화살표의 목표 객체는 다음 화살표의 원본 객체여야 합니다. 우리가 프로그래밍에서 한 함수의 결과값을 다른 함수로 보내는 것처럼요. 만약 목표 함수가 원본 함수에서 생성되는 데이터를 완벽하게 이해하지 못한다면 프로그램은 작동하지 않을 것입니다. 함수가 합성하려면 합성하려는 각 함수의 한쪽 끝이 일치해야 합니다. 언어의 타입 시스템이 더 강력할수록 타입 일치가 더 나아진다는 사실은 기계적으로 증명됐었고 설명도 가능합니다.

한 가지 주장은 강력한 정적 타입 확인이 의미상으로 올바른 프로그램을 제거할 수도 있다는 것입니다. 실제로 이런 일이 일어날 확률은 극단적이지만 모든 언어가 이러한 상황을 위해 백도어같은 것을 만들어두는 것은 꼭 필요하다고 생각합니다. 심지어 하스켈에서도 `unsafeCoerce` 가 존재합니다. 그렇지만 그런 기능은 분별력 있게 사용해야 합니다. 그레고르 잠자는 프란츠 카프카 소설의 한 인물인데, 작가가 큰 갑충으로 비유하는 순간 타입 시스템이 파괴되었고 결국에 그는 죽음을 맞이하였습니다.

또 다른 주장은 타입을 다루게 하는 것은 프로그래머에게 너무 많은 짐을 지어준다는 것입니다. 저는 이러한 감정을 몇몇 C++ 이터레이터를 선언할 때 느껴봐서 공감할 수 있습니다. 컴파일러가 타입이 쓰이는 곳을 보고 추론하는 기술인 타입 추론이 있지만, 그것은 예외로 치겠습니다. C++에서는 `auto` 변수를 선언하고 컴파일러가 그 변수의 타입을 알아내게 하는 방식도 존재합니다.

하스켈에선 몇 없는 예외 사항을 제외하고 타입 어노테이션은 순수하게 선택입니다. 코드의 의미를 설명할 수 있으며 컴파일 에러가 이해하기 쉬워진다는 이유로 프로그래머들은 대부분 사용하는 편입니다. 이것은 하스켈에서 타입을 디자인하는 것으로부터 프로젝트를 시작하는 흔한 방식입니다. 나중에는 타입 어노테이션이 구현을 이끌고 컴파일러가 강요하는 내용이 될 것입니다.

강력한 정적 타입을 쓰는 것은 종종 코드를 테스트하지 않는 것에 대한 변명이 되기도 합니다. 하스켈 프로그래머들이 다음과 같은 말을 하는 것을 들어보셨을 수도 있습니다. "컴파일이 된다면 그건 반드시 옳아." 물론 타입이 옳은 프로그램이 옳바른 출력을 한다는 보장은 없습니다. 이러한 무신경한 태도의 결과인지 몇몇 연구에서 하스켈은 생각한 것만큼 앞선 코드 퀄리티를 보여주지 못했습니다. 저는 소프트웨어 개발자를 경제학적으로 보는 시선과 기다려주지 않는 엔드 유저 그리고 언어나 방법론에 긴 시간을 쓸 수 없는 상업적인 환경에서 버그를 고쳐야하는 압력은 코드 품질에 영향을 줘서 어느 정도 한계가 생겼다고 생각합니다. 더 나은 기준은 스케쥴을 넘어서는 프로젝트의 수 또는 기능성을 급격하게 줄여서 배포되는 프로젝트의 수를 측정하면 될 것입니다.

유닛 테스트가 강력한 타입 사용을 대체할 수 있다는 주장의 경우엔 강력한 타입 언어에서 사용되는 보통의 리팩토링인 특정 함수 인자의 타입을 변경하는 경우를 생각해보면 됩니다. 강력한 타입 언어에선 함수의 선언만 수정하고 빌드 오류만 수정하면 됩니다. 약한 타입 언어에선 함수가 이제 다른 타입을 사용한다는 추론을 호출하는 부분에선 알 방법이 없습니다. 유닛 테스트는 몇몇 불일치는 잡아낼 수 있겠지만 테스트는 언제나 결정론적보다는 확률적인 과정이라 증명을 대신하는 것엔 형편없습니다.

## 타입은 무엇일까요?

가장 간단하고 직관적으로 말하자면 타입은 값들의 집합입니다. Bool(하스켈의 구체 타입은 대문자로 시작합니다!)이라는 타입은 `True` 와 `False` 를 원소로 받는 집합입니다. `Char` 타입은 `'a'` 또는 `'ą'` 처럼 모든 유니코드의 집합입니다.

집합은 유한할 수도 무한할 수도 있습니다. `Char` 의 배열이라고도 할 수 있는 `String` 타입은 유한 집합의 한 예입니다.

`x` 를 `Integer` 라고 정의해보겠습니다.

```
x :: Integer
```

우리는 x를 정수 집합의 원소라고 말할 수 있습니다. 하스켈의 `Integer` 는 유한 집합이고 임의 정밀도 산술(Arbitrary Precision Arithmetic)을 할 수 있습니다. 하스켈엔 또 다른 유한 집합인 `Int` 가 있는데 이는 C++의 `Int` 처럼 기계 타입에 대응합니다.

순환 정의를 수반하는 다형성 함수를 사용할 때 생기는 문제와 모든 집합에 대한 집합을 가질 수 없다는 사실이 타입과 집합을 구별하기 까다롭게 하는 몇 가지 애매한 점입니다. 하지만 저는 수학에 그렇게 까다로운 사람이 아닙니다. 훌륭한 점은 **Set** 이라고 불리는 집합의 카테고리가 있다는 것과 우리는 이것만 사용하면 된다는 것입니다. **Set** 의 객체는 집합이고 사상(morphism, 화살표)은 함수 역할을 합니다.

**Set** 는 아주 특별한 카테고리인데, 왜냐하면 내부에서 그것의 객체를 선택할 수 있고 그렇게 함으로서 많은 직관을 얻게 되기 때문입니다. 예를 들면 우리는 빈 집합은 원소를 가지고 있지 않다는 사실을 알고 있습니다. 우리는 하나의 원소만 가지는 특별한 집합이 있다는 사실을 알고 있습니다. 우리는 함수가 한 집합의 원소를 다른 집합의 원소로 매핑(map)해준다는 것을 알고 있습니다. 또한 두 원소를 하나의 원소로 매핑하는 일은 가능하지만 하나의 원소를 둘 이상의 원소로 매핑하는 것은 불가능하다는 것도 알고 있습니다. 저의 계획은 이러한 정보를 점진적으로 모두 잊게 하고 그러한 내용을 순수한 카테고리 적인 용어(객체와 화살표)로 표현할 수 있게 바꾸는 것입니다.

이상적인 세계에선 하스켈의 타입이 집합이고 하스켈의 함수가 집합 사이의 수학적인 함수라고 할 수 있습니다. 하지만 수학적인 함수는 아무 코드도 실행하지 않는다는 작은 문제가 있습니다. 그저 답을 알고 있을 뿐입니다. 하스켈의 함수는 답을 계산하게 되어있습니다. 답이 아무리 크더라도 유한한 숫자 범위 안에 포함된다면 문제가 없습니다. 하지만 재귀를 일으키는 계산이 존재하고 그것들은 절대 끝나지 않습니다. 끝나지 않는 함수를 무조건적으로 하스켈에서 없앨 수는 없습니다. 이는 유명한 정지 문제(Halting Problem)처럼 어떤 것이 끝날 함수고 어떤 것이 끝나지 않을 함수인지 구별할 수가 없기 때문입니다. 여기서 컴퓨터 과학자들은 아주 영리하게 바텀 타입(bottom type)을 생각해냈고 기호로 쓰면 `_|_` (유니코드론 ⊥)입니다. 이 "값"은 끝나지 않을 계산을 의미합니다. 아래와 같은 함수가 있다고 해보겠습니다.

```
f :: Bool -> Bool
```

위 함수는 `True` , `False` 또는 절대 끝나지 않는다는 의미의 `_|_` 를 반환할 것입니다.

흥미롭게도 여러분이 이 바텀 타입을 타입 시스템의 일부로 받아들이는 순간, 모든 런타임 에러를 간편하게 바텀 타입으로 취급하게 되고 심지어 함수가 명시적으로 이 기호를 반환하도록 하기도 합니다. 후자의 경우엔 보통 `undefined` 라는 표현으로 사용됩니다.

```
f :: Bool -> Bool
f x = undefined
```

`undefined` 는 `Bool` 을 포함하여 어떤 타입도 될 수 있기 때문에 위 정의는 아래와 같이 쓸 수도 있습니다.

```
f :: Bool -> Bool
f = undefined
```

(`x` 가 없어졌습니다)

왜냐하면 바텀 타입은 `Bool->Bool` 의 일부이기도 하기 때문입니다.

바텀 타입을 반환하는 함수는 부분(partial) 정의 함수이라고 불리는데, 이는 모든 가능한 경우에 대해 유효한 결과만 반환하는 종합(total) 함수와 반대되는 내용입니다.

바텀덕분에 우리는 **Set** 대신에 하스켈의 타입과 함수들의 카테고리인 **Hask** 를 사용할 수 있을 것입니다. 이론적인 측면에서 이는 끝나지 않는 복잡함의 시작이겠지만 이 시점에 저는 만능칼을 꺼내서 이를 증명하는 부분을 잘라내려고 합니다. 프로그래밍적인 측면에서 끝나지 않는 함수와 바텀 타입은 무시해도 괜찮은 부분이고 **Hask** 를 진짜 **Set** 이라고 취급해도 괜찮습니다(글의 끝에 있는 참고문헌 부분을 확인해주세요).

## 왜 수학적 모델이 필요할까요?

프로그래머들은 각자의 프로그래밍 언어의 문법에 매우 친밀할 것입니다. 언어의 이러한 측면은 보통 언어 스펙의 앞쪽에 있는 공식적인 표기법으로 설명됩니다. 하지만 언어의 의미를 설명하는 것은 비공식적인 문서도 더 많이 필요하고 거의 절대로 완성되지 않는 어려운 일입니다. 언어 변호사들의 끝나지 않는 토론의 이유로 모든 책 가내 수공업들은 언어 표준의 더 나은 지점의 주해를 위해 공헌 됩니다.

언어의 의미를 설명하는 공식적인 도구가 존재하지만 그들의 복잡도 때문에 간단한 학문적 언어들에만 쓰이고 실생활의 프로그래밍 언어에서는 쓰이지 않습니다. 거기선 표준화되고 최적화된 인터프리터를 정의합니다. C++과 같은 산업적 언어의 의미는 비공식적인 연산 추론을 통해 설명되고 이는 보통 "추상 기계(abstract machine)"라고 불립니다.

문제는 운용 의미론(operational semantic)을 사용하는 프로그램의 증명이 매우 어렵다는 것입니다. 프로그램의 속성을 보려면 반드시 최적화된 인터프리터에서 "실행"해야 하기 때문입니다.

프로그래머는 옳음에 대해 공식적인 증명을 하지 않아도 괜찮습니다. 우리는 항상 우리가 옳은 프로그램을 작성한다고 "생각"합니다. 키보드에 앉아서 "오 내가 코드 몇 줄 작성했으니 무슨 일이 일어나는지 봐"라고 하는 사람은 아무도 없습니다. 보통은 작성하는 코드가 내가 원하는 특정한 액션을 할 거라 생각합니다. 그렇게 되지 않았을 경우 놀라죠. 이는 우리가 작성하는 프로그램에 대해 머릿속에 있는 인터프리터를 사용해 실행해본다는 것을 의미합니다. 그렇지만 모든 변수를 기억하고 있는 것은 정말 어려운 일입니다. 컴퓨터는 프로그램을 실행하는 데에 특화돼있지만 인간은 그렇지 않습니다! 그랬다면 우린 컴퓨터가 필요 없었겠죠.

하지만 대체재는 존재합니다. 이는 표시적 의미론(denotational semantic)이라고 하는데 수학에 기반하고 있습니다. 표시적 의미론에선 모든 프로그래밍 구성품들이 수학적인 인터프리터를 가집니다. 그렇게 되면 프로그램의 특정 속성을 증명하고 싶을 때 수학적 정리만 증명하면 됩니다. 정리를 증명하는 것이 어려울 수 있지만, 우리 인간들은 몇천 년 동안 수학적 메소드를 쌓아왔기 때문에 축적된 지식이 많습니다. 또한 전문적인 수학가가 증명하는 정리에 비교해서 프로그래밍에서 마주치는 문제들은 보통 상대적으로 간단합니다.

하스켈에서 표시적 의미론을 받아들일 수 있는 팩토리얼 함수의 정의를 예로 들어보겠습니다.

```
fact n = product [1..n]
```

`[1..n]` 라는 표현은 1부터 n까지의 정수의 목록을 나타내는 표현입니다. `product` 라는 함수는 목록에 있는 모든 요소를 곱한다는 의미입니다. 이는 수학 문서에서 가져온 팩토리얼 정의와 비슷하게 생겼습니다.
이제 C로 만든 예제롤 보겠습니다.

```
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

더 얘기해볼까요?

좋습니다. 솔직히 너무 쉬운 예제였다는 것을 인정하겠습니다! 팩토리얼 함수는 명백하게 수학적인 의미를 가집니다. 어떤 분들은 키보드에서 텍스트 읽어오기나 네트워크에 패킷을 보내는 것에 어떤 수학적 모델이 있는지 질문하실 수도 있습니다. 그것은 오랫동안 복잡한 설명을 해주는 것 대신에 어색하게 만드는 질문이었을 것입니다. 제가 보기에 표시적 의미론은 유용한 프로그램을 작성하는 데에 필수가 되는 중요한 업무는 아닌 것 같습니다. Eugenio Moggi는 컴퓨터의 효과는 모나드(Monad)로 매핑될 수 있다는 것을 발견했습니다. 이는 표시적 의미론에 새로운 인생이 시작되게 하고 순수 함수형 프로그래밍을 더 유용하게 만들었을 뿐만 아니라 전통적 프로그래밍에 새로운 빛을 제공했습니다. 모나드(Monad)에 대해선 나중에 우리가 카테고리에 대해 더 많이 알게 된 이후에 얘기하도록 하겠습니다.

프로그래밍에 수학적 모델을 적용하는 것의 큰 이점 중 하나는 소프트웨어의 옳음에 대해 공식적으로 증명할 수 있게 되었다는 것입니다. 이는 컴퓨터 소프트웨어를 작성할 때는 그렇게 도움 되는 내용은 아니지만, 프로그래밍의 가격과 실패가 엄청난 타격을 주거나 사람의 생명이 위태로울 경우가 있습니다. 그리고 건강 시스템을 위한 웹 어플리케이션을 작성할 때도 하스켈 표준 라이브러리에서 옳음에 대해 증명된 함수와 알고리즘을 사용하면 됩니다.

## 순수한 함수와 지저분한 함수

C++이나 다른 명령형 언어에서 우리가 함수라고 부르는 것들은 수학 함수의 의미와는 조금 다릅니다. 수학의 함수는 그저 값을 값으로 매핑하는 것이라고 할 수 있습니다.

물론 프로그래밍 언어도 입력 값을 받고 출력 값을 계산해서 돌려주는 수학적인 함수를 구현할 수 있습니다. 입력된 수의 제곱을 반환하는 함수는 아마 입력 받은 값을 입력 받은 값으로 곱할 것입니다. 이러한 작업은 같은 값을 입력했는지 여부와는 상관없이 호출될 때마다 실행될 것입니다. 우리가 보는 달의 방향이 바뀌지 않는 것처럼 수의 제곱값은 절대 바뀌지 않는데도 말이죠.

또한 수의 제곱값을 계산하는 것은 여러분이 키우는 강아지에게 간식을 주는 것과 같은 사이드 이펙트를 만들어내지 않아야 합니다. "함수"는 수학의 함수로 쉽게 모델링될 수 없습니다.

프로그래밍 언어에서는 같은 입력에 대해 항상 같은 결과를 반환하고 사이드 이펙트가 없는 함수를 두고 순수 함수(pure function)라고 부릅니다. 하스켈과 같은 순수 함수형 언어에선 모든 함수가 순수합니다. 이 덕분에 이러한 언어에선 표시적 의미론과 카테고리 이론을 사용한 모델을 만들기가 쉽습니다. 다른 언어에선 자기 자신에게 항상 순수하고 사이드 이펙트가 분리된 함수를 만들도록 제한한다면 가능할 것입니다. 그 후엔 모나드가 우리에게 순수한 함수로 모든 종류의 효과를 모델링할 수 있게 해줄 것입니다. 그러니 우리는 우리 자신을 수학적 함수만 만들도록 제한해도 전혀 잃을 것이 없습니다.

## 타입의 예시

타입이 집합이라는 것을 깨달으셨다면 좀 더 새로운 타입에 대해 생각할 수 있을 것입니다. 예를 들면 빈 집합에 대응하는 타입은 무엇일까요? C++의 `void` 는 아닙니다. 하지만 하스켈의 `Void` 는 맞습니다. 이는 아무 값도 존재하지 않는 것의 타입입니다. 여러분이 `Void` 를 받는 함수를 만든다면 정의는 가능하겠지만 호출할 순 없을 것입니다. 이 함수를 호출하려면 `Void` 타입의 값을 제공해야 하는데 이 타입에 해당하는 값은 아무것도 없기 때문입니다. 물론 반환하는 것은 무슨 타입이든 가능합니다. (비록 호출할 수 없어서 절대 반환하는 일은 없겠지만요.) 다른 말로 하자면 이것은 반환 타입의 다형성인 함수라고 할 수 있습니다. 하스켈엔 이러한 개념을 다음과 같이 부릅니다.

```
absurd :: Void -> a
```

(`a` 는 어떤 타입도 표현하는 타입 변수라는 것을 기억해주세요) 이름이 absurd(터무니없는, 불합리)라는 이름이 지어진 것은 우연이 아닙니다. 좀 더 깊이 들어가면 인터프리터에선 Curry-Howard 동형(isomorphism)이라는 타입과 함수를 해석하는 로직이 존재합니다. `Void` 라는 타입은 거짓을 의미하며, `absurd` 함수는 라틴어 속담인 "잘못된 전제에서 오는 모든 명제는 참이다(ex falso sequitur quodlibet)"라는 내용을 가집니다.

다음은 싱글톤 집합에 대응하는 타입입니다. 이 타입은 오직 하나의 값만 가질 수 있습니다. 바로 생각이 안날수도 있습니다. C++의 `void` 라고 생각하시면 됩니다. 이 타입을 입력으로 받거나 출력으로 반환하는 함수를 생각해봅시다. `void` 를 입력으로 받는 함수는 언제나 호출할 수 있습니다. 만약 이 함수가 순수 함수라면 항상 같은 결과를 반환할 것입니다. 그러한 예시를 들어보겠습니다.

```
int f44() { return 44; }
```

이 함수가 "아무것도" 입력으로 받지 않는다고 생각하실 수도 있습니다. 하지만 위에서 "아무것도" 받지 않는 함수의 경우엔 "아무것도"를 표현하는 값이 없기 때문에 호출될 수 없다는 것을 보았습니다. 그러면 이 함수는 무엇을 받는 걸까요? 개념적으론 이 함수는 딱 하나만 존재하는 인스턴스의 더미 값을 받기 때문에 우리는 굳이 언급할 필요가 없어서 적지 않는 것입니다. 그러나 하스켈에선 이러한 값을 표시하는 상징이 따로 있습니다. 바로 괄호쌍(`()`) 입니다. 재밌는 우연의 일치(혹은 우연이 아닐 수도 있겠죠?)는 C++과 하스켈의 void 함수를 호출하는 모양새가 똑같다는 것입니다. 또한 하스켈의 간결함 덕분에 `()` 는 타입과 생성자 그리고 싱글톤 집합에 대응하는 값에만 사용됩니다. 그래서 위 함수를 하스켈로 표현하면 다음과 같습니다.

```
f44 :: () -> Integer
f44 () = 44
```

첫 줄은 `f44` 함수가 `()` ("유닛(unit)"이라고 부릅니다) 타입을 입력으로 받고 `Integer`타입을 반환한다는 내용입니다. 두번째 줄에선 `f44` 를 `()` 생성자로 패턴 매칭을 해서 44만 생성하도록 만들었습니다. 이 함수는 유닛 값인 `()` 만 제공하면 호출할 수 있습니다.

```
f44 ()
```

유닛을 입력으로 받는 모든 함수는 동등하게 하나의 타겟 타입 요소(여기선 `Integer` 44입니다)를 반환합니다. 사실상 `f44` 는 숫자 44의 또 다른 표현이라고 생각하실 수도 있습니다. 이게 바로 직접적으로 집합의 특정 요소를 언급하는 것 대신에 함수(화살표)를 말하는 예시 중 하나입니다. 유닛을 받아서 A 타입을 반환하는 함수는 A 집합의 요소 하나에 일대일 대응합니다.

`void` 를 반환 타입으로 가지거나 또는 하스켈의 유닛을 반환 타입으로 가지는 경우는 어떨까요? C++에선 그러한 함수는 사이드 이펙트를 만들기 위해 사용되지만 우리는 이러한 함수는 수학적으로 보면 함수라고 할 수 없다는 것을 알고 있습니다. 순수 함수는 유닛을 반환하면서 아무런 사이드 이펙트도 없어야 합니다.

수학적으로 A 집합에서 싱글톤으로 가는 함수는 A 집합의 모든 원소가 싱글톤 집합의 하나의 싱글톤 원소에 대응합니다. 모든 A 원소에 대해 하나의 함수만 존재한다는 것입니다. `Integer` 타입의 예를 들어보겠습니다.

```
fInt :: Integer -> ()
fInt x = ()
```

어떠한 정수 값을 주어도 유닛을 반환합니다. 간결함의 규칙으로 인해 하스켈은 와일드카드 패턴인 언더스코어(*_*)를 사용해서 불필요한 내용을 없앨 수 있게 해줍니다. 이 방식을 사용하면 여러분은 이 함수의 이름을 생각할 필요가 없어집니다. 이 패턴을 사용해서 다시 작성해보겠습니다.

```
fInt :: Integer -> ()
fInt _ = ()
```

주의: 이 함수의 구현 내용은 어떤 값을 주는지에 따라 상관없지만, 타입을 상관하지 않는 것은 아닙니다.

어떤 타입이든 이와 같은 공식으로 구현되는 함수는 매개변수 다형성(parametrically polymorphic)라고 부릅니다. 구체적인 타입을 지정하지 않고 타입 변수를 사용하는 것으로 모든 타입에 대한 함수를 생성할 수 있습니다. 어떤 변수든 유닛 타입으로 가는 다형성 함수는 뭐라고 불러야 할까요? 당연하게도 우리는 이것을 `unit` 이라고 부릅니다.

```
unit :: a -> ()
unit _ = ()
```

C++에선 다음과 같이 코드를 작성할 수 있습니다.

```
template<class T>
void unit(T) {}
```

다음은 두 개의 원소를 가진 집합을 나타내는 타입입니다. C++에선 이를 `bool` 이라 부르고 하스켈에선 다들 예상하셨듯이 `Bool` 이라고 부릅니다. C++의 `bool` 과 하스켈의 `Bool` 의 차이점은 C++에선 내장 타입인 반면 하스켈에선 다음과 같이 정의할 수 있다는 것입니다.

```
data Bool = True | False
```

(Bool은 True와 False 값을 가지는 정의로 읽으시면 됩니다)
C++에선 Boolean 타입을 열거형으로 정의해둬서 둘 중 하나의 값을 가집니다.

```
enum bool {
    true,
    false
};
```

하지만 C++의 `enum` 은 사실은 정수입니다. C++11의 "`enum class`" 가 대신 쓰일 수도 있지만 그렇게 한다면 `bool::true` 와 `bool::false` 같이 값을 표시할 때 클래스 이름도 같이 적어야 할 것입니다. 모든 파일에서 헤더를 추가하게 될 것은 말하지 않겠습니다.

`Bool`의 순수 함수는 그저 하나의 값을 `True`나 `False`로 대응하는 것입니다.

`Bool`의 함수는 *predicates* 라고 부릅니다. 예를 들면 하스켈 라이브러리 `Data.Char`엔 `isAlpha`나 `isDigit`와 같은 predicates로 가득합니다. C++에도 `isalpha`나 `isdigit`같은 함수를 제공하는 라이브러리가 있지만, 이 함수들은 Boolean이 아닌 `int`를 반환합니다. predicates는 `std::ctype`이라는 라이브러리에 있고 `ctype::is(alpha, c)`, `ctype::is(digit, c)` 등의 형식을 가집니다.

## 도전 과제

1. 제일 좋아하는 언어로 `memoize` 라는 고계 함수(또는 함수 객체)를 정의하세요. 이 함수는 순수 함수 `f` 를 인자로 받고 `f` 와 거의 똑같은 행동을 하는 함수를 반환합니다. 그리고 모든 인자에 대해 원래 함수를 한 번씩만 호출하며 결과를 내부적으로 저장하고 같은 입력이 올 경우 함수를 호출하지 않고 저장된 값을 반환해야 합니다. 그 후엔 오랜 시간이 드는 인자를 넘겨서 함수의 퍼포먼스를 확인해 보세요. 처음엔 오래 걸릴지 몰라도 그다음부턴 같은 인자에 대해선 즉시 값을 반환해야 합니다.

2. memoize 함수에 넘기는 인자를 무작위 숫자로 바꿔보세요. 잘 작동하나요?

3. 대부분의 무작위 숫자 생성기는 시드를 통해 초기화할 수 있을 것입니다. 시드를 받는 함수를 만들고 그 시드를 통해 무작위 숫자 생성기를 호출하고 결과를 반환해보세요. 그리고 그 함수를 memoize 함수로 만들어보세요. 잘 작동하나요?

1. 다음 중 어떤 C++ 함수가 순수할까요? 이들을 memoize로 만들어보고 여러 번 호출했을 때 원래 함수와 새로운 함수에 어떤 일이 일어나는지 확인해보세요.

  4-1. 글에 예제로 나온 팩토리얼 함수

  4-2.
```
std::getchar()
```

  4-3.
```
bool f() {
  std::cout << "Hello!" << std::endl;
  return true;
}
```

  4-4.
```
int f(int x)
{
	static int y = 0;
	y += x;
	return y;
}
```

5. `Bool` 에서 `Bool` 로 가는 서로 다른 함수는 몇 개가 있을까요? 모두를 구현할 수 있으신가요?

1. `Void` , `()` (유닛) 그리고 `Bool` 타입을 객체로 가지는 카테고리의 그림을 그려보세요. 이 타입들에 모든 가능한 함수에 대응하는 화살표를 그려주세요. 함수의 이름을 화살표에 써주세요.

## 참고 문헌

1. Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, [Fast and Loose Reasoning is Morally Correct](http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf).

다음: [다양한 종류의 카테고리](/contents/part1/categories-great-and-small.md)

---

공부 목적으로 번역을 하고 있습니다! 잘못된 점에 대한 이슈나 PR은 언제든지 환영합니다 :)
